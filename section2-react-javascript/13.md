# 배열 내장함수

자바스크립트의 배열은 유용한 내장함수를 많이 가지고 있습니다

이러한 내장함수들을 적절하게 이용하면 훨씬 유연하고 깔끔한 코딩이 가능하기 때문에, 이번시간에는 배열 내장함수에 대해 이야기 해 보도록 하겠습니다.

## 01. forEach

단순 배열을 순회하기 위해 우리는 반복문을 이용한 아래와 같은 코드를 작성했어야 했습니다.

```javascript
const arr = [1, 2, 3, 4];

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

이런 코드가 나쁘다는 것은 아닙니다만, 배열 내장함수를 이용하면 훨씬 간결하게 작성할 수 있습니다.

아래의 코드를 함께 작성해볼까요?

```javascript
const arr = [1, 2, 3, 4];

arr.forEach((elm) => console.log(elm));
```

배열 내장함수를 처음 이용하신 분들께서는 조금 의아할 수 있습니다, `forEach` 호출까지는 알겠는데 그 속에는 .. 뭐지?

2섹션의 7번과 8번 강의에서 우리는 함수와 함수 표현식에 대해 배웠습니다.

그때 `콜백 함수`라는 개념 또한 배웠습니다

다시 복습해보자면 콜백함수라는 것은 특정 동작을 수행한 이후에 수행될 함수를 의미합니다.

`forEach`는 아래 코드처럼 첫번째 파라미터로 이 `콜백함수`를 전달받고 있습니다

```javascript
const arr = [1, 2, 3, 4];
arr.forEach(콜백함수);
```

이 콜백함수를 전달하는 방법은 간단합니다. 함수 표현식으로 변수에 저장된 함수를 전달하거나, 아니면 표현식 자체를 즉시 전달하는 방법입니다.

```javascript
const arr = [1, 2, 3, 4];

const callBack = () => {};

// 1번 : 변수에 저장된 함수 전달
arr.forEach(callBack);

// 2번 : 즉시 전달
arr.forEach(function () {});

// 3번 : 화살표 함수로 즉시 전달
arr.forEach(() => {});
```

그런데 forEach메서드는 는 왜 우리에게 콜백함수를 파라미터로 요구하는 것 일까요?

그것은, forEach주어진 함수 `콜백함수`를 배열의 요소 각각에 대해 모두 실행하기 위해 만들어졌기 때문입니다.

아래의 예제를 다시 볼까요?

```javascript
const arr = [1, 2, 3, 4];

arr.forEach((elm) => console.log(elm));
```

위 예제는 이렇게 해석할 수 있습니다

"arr 배열의 요소 각각(1,2,3,4)에 대해 console.log를 수행해라!"

## 02. map

`map` 메서드는 배열 내의 모든 요소 각각에 대해, 주어진 콜백함수를 호출한 결과를 모아서 새로운 배열로 반환합니다.

```javascript
const arr = [1, 2, 3];
arr.map(콜백함수); // 새로운 배열을 반환한다.
```

설명이 어렵게 느껴진다면 아래 코드와 함께 보시면 이해가 조금 수월하실 겁니다.

```javascript
const arr = [1, 2, 3, 4];

console.log(
  arr.map((elm) => {
    return elm * 2;
  })
);
```

위 코드의 결과는 `arr`배열의 각 원소에 2씩을 곱한 형태가 됩니다 즉,
`[2, 4, 6, 8]` 의 결과가 나오게 됩니다.

어떻게 이런 새로운 배열을 반환하는 것 일까요?

우리가 위에서 사용해본 `forEach`와 `map`의 콜백함수는 크게 다르지 않습니다만, 한가지 차이가 존재합니다.

`forEach`의 콜백함수에는 `return` 구문이 존재하지 않았지만, `map`의 콜백함수에는 존재합니다 즉 각각의 요소에 대해서 무언가 반환을 하고 있다는 뜻 입니다.

`map`을 사용하여 배열의 모든 원소에 2씩을 곱하는 예제를 다시 한번 살펴보겠습니다.

```javascript
arr.map((elm) => {
  return elm * 2;
});
```

위 예제의 콜백함수에 집중해서 살펴보세요, 각각의 요소들을 모두 `*2` 한 형태로 return 하고 있습니다

즉, `map`은 배열 내 모든요소에 적용되는 콜백함수의 `return`값들을 합쳐 새로운 배열을 만들어 내는 메서드라고 볼 수 있습니다.

## 03. indexOf

배열은 인덱스를 통해 접근하는 순차적 자료구조입니다.

찾고자 하는 요소의 인덱스를 정확히 알고 있다면, 인덱스를 통해 빠르게 접근할 수 있습니다.

그러나 찾고자 하는 요소의 값은 알지만, 인덱스는 모르는 상황에서는 어떻게 해야 할까요?

`indexOf` 메서드는 이러한 상황에서 유용하게 사용될 수 있습니다 이 메서드는 특정값과 배열내에서 일치하는 값의 `인덱스`를 반환하는 함수입니다.

아래 예제를 통해 사용해보도록 하겠습니다.

```javascript
const arr = [1, 2, 3, 4];
const idx = arr.indexOf(3);
console.log(idx); // 2
```

1 부터 4까지 담고있는 배열 arr에서 3이라는 값을 가진 요소의 인덱스를 반환해주고 있는 모습을 볼 수 있습니다.

## 04. findIndex

우리는 위에서, 배열 내에서 특정 값을 가지고 있는 요소의 인덱스를 반환받는 방법을 배웠습니다.

그런데 찾아야 하는 값이 객체이거나 배열이라면 어떨까요?

```javascript
const arr = [
  { name: "이정환", color: "black" },
  { name: "신다민", color: "white" },
  { name: "김효빈", color: "green" },
  { name: "이종원", color: "red" },
];
```

이 배열에서 이름이 '신다민'인 요소의 인덱스를 찾으려면 어떻게 해야 할까요?

이렇게 배열 내 요소의 값이 객체이거나, 배열이라는 indexOf로 찾을 수 없습니다.

이럴때 사용할 수 있는 메서드가 바로 `findIndex`입니다.

아래의 예제를 통해 `findIndex`를 사용해 보도록 하겠습니다.

```javascript
const arr = [
  { name: "이정환", color: "black" },
  { name: "신다민", color: "white" },
  { name: "김효빈", color: "green" },
  { name: "이종원", color: "red" },
];

const idx = arr.findIndex((elm) => elm.name === "신다민");
console.log(idx); // 1
```

결과가 잘 나오나요?

`findIndex`는 배열의 모든 요소에 대해 순차적으로 콜백함수를 수행하며, 콜백함수의 일치 여부를 가장 먼저 만족하는 배열의 요소의 인덱스를 반환합니다.

## 05. find

`findIndex`를 통해서 원하는 요소의 인덱스를 찾고, 해당 인덱스를 갖는 요소에 접근하는 방법은 아래와 같습니다.

```javascript
const arr = [
  { name: "이정환", color: "black" },
  { name: "신다민", color: "white" },
  { name: "김효빈", color: "green" },
  { name: "이종원", color: "red" },
];

const idx = arr.findIndex((elm) => elm.name === "신다민");
const targetElm = arr[idx];
console.log(targetElm); // { name: "신다민", color: "white" }
```

`find` 메서드를 이용하면 더 빠른 방식으로 조건에 일치하는 요소에 접근할 수 있습니다

```javascript
const arr = [
  { name: "이정환", color: "black" },
  { name: "신다민", color: "white" },
  { name: "김효빈", color: "green" },
  { name: "이종원", color: "red" },
];

const targetElm = arr.find((elm) => elm.name === "신다민");
console.log(targetElm); // { name: "신다민", color: "white" }
```

무엇이 바뀌었는지 눈치 채셨나요?

`find` 는 인덱스를 반환하는 `findIndex`와는 다르게, 조건에 맞는 요소 그 자체를 반환합니다

## 06. filter

배열에서 조건에 맞는 요소의 인덱스를 찾고, 심지어 그 요소가 무엇인지 까지 찾아보았습니다.

그러나, 이러한 조건에 일치한 요소가 여러개라면 어떻게 될까요?

아래 예제 코드의 `arr` 배열에서 color가 green인 요소들을 모두 찾아내고 싶다면 어떻게 해야 할까요?

```javascript
const arr = [
  { name: "이정환", color: "green" },
  { name: "신다민", color: "white" },
  { name: "김효빈", color: "green" },
  { name: "이종원", color: "red" },
];
```

find와 findIndex는 한번에 하나의 요소만 찾을 수 있기 때문에, 여러개의 요소를 찾아낼 수 없습니다.

`filter` 메서드는 이럴때 유용하게 사용될 수 있습니다.

`filter` 메서드는 배열의 요소 중 조건에 일치하는 모든 요소를 다시 배열로 묶어 반환합니다.

아래 예제를 통해, color가 green인 모든 요소들을 배열로 추출해 보도록 하겠습니다.

```javascript
const arr = [
  { name: "이정환", color: "green" },
  { name: "신다민", color: "white" },
  { name: "김효빈", color: "green" },
  { name: "이종원", color: "red" },
];

const greenElements = arr.filter((elm) => elm.color === "green");
console.log(greenElements); // [{name:"이정환", color:"green"}, {name:"김효빈", color:"green"}]
```

## 07. push

배열에 요소를 추가하는 방법은 매우 간단합니다.

`push` 메서드를 사용하여 원하는 요소를 추가할 수 있습니다.

> push 메서드는 항상 배열의 맨 뒤에 요소를 추가합니다.

```javascript
const arr = [
  { name: "이정환", color: "green" },
  { name: "신다민", color: "white" },
  { name: "김효빈", color: "green" },
  { name: "이종원", color: "red" },
];

arr.push({ name: "홍길동", color: "purple" });
console.log(arr);

// output
// [
//   { name: "이정환", color: "green" },
//   { name: "신다민", color: "white" },
//   { name: "김효빈", color: "green" },
//   { name: "이종원", color: "red" },
//   { name: "홍길동", color: "purple" },
// ]
```

## 08. splice

배열에 요소를 추가했다면 `splice` 메서드를 사용하여 요소를 삭제할 수도 있습니다.

다음은 배열에서 하나의 요소를 삭제하는 예제입니다.

```javascript
const arr = [
  { name: "이정환", color: "green" },
  { name: "신다민", color: "white" },
  { name: "김효빈", color: "green" },
  { name: "이종원", color: "red" },
];
arr.splice(0, 1); // 이정환 삭제
console.log(arr);

// output
// [
//   { name: "신다민", color: "white" },
//   { name: "김효빈", color: "green" },
//   { name: "이종원", color: "red" }
// ]
```

이정환이라는 name을 갖는 0번째 배열의 요소가 삭제되었습니다

`splice`메서드는 일반적으로 `start`와 `deleteCount` 이렇게 두가지의 파라미터를 받는데요, 위의 예제에서는 파라미터를 다음과 같이 전달했습니다.

> start : 0 (0번째 요소부터 삭제해라)
>
> deleteCount : 1 (1개만 삭제해라)

즉 0번째 요소부터 1개만 삭제해라 => 0번째 요소 1개만 삭제해라 라는 뜻이 되어, 0번째 인덱스에 해당하는 요소인 이정환이 삭제되었습니다.

> `splice`를 사용해서 배열의 요소를 삭제하면, 기존의 배열의 값이 변경됩니다.

## 09. slice

`slice`는 기존의 배열의 값은 수정하지 않고, 우리가 원하는 부분만 잘라내서 복사하는 역할을 하는 메서드입니다.

아래의 예제를 통해 `slice`를 사용해 보도록 하겠습니다.

```javascript
const arr = [
  { name: "이정환", color: "green" },
  { name: "신다민", color: "white" },
  { name: "김효빈", color: "green" },
  { name: "이종원", color: "red" },
];
const sliceArr = arr.slice(0, 2);
console.log(sliceArr);

// output
// [
//   { name: "이정환", color: "green" },
//   { name: "신다민", color: "white" }
// ]
```

`slice`는 두개의 파라미터 begin부터 end까지 (end 미포함) 배열을 복사하여 새로운 배열 객체로 반환합니다.

## 10. concat

`concat` 메서드를 이용하면 두개의 배열을 이어 붙일 수 있습니다.

```javascript
const arr = [
  { name: "이정환", color: "green" },
  { name: "신다민", color: "white" },
];

const arr2 = [
  { name: "김효빈", color: "green" },
  { name: "이종원", color: "red" },
];

const totalArr = arr.concat(arr2);
console.log(totalArr);

// output
// [
//   { name: "이정환", color: "green" },
//   { name: "신다민", color: "white" },
//   { name: "김효빈", color: "green" },
//   { name: "이종원", color: "red" }
// ]
```

## 11. join

가끔은 배열 내의 모든 요소들을 문자열 형태로 합쳐야 할 상황이 존재합니다.

이럴때는 `join` 메서드를 활용하여 수행할 수 있습니다

```javascript
const arr = ["이정환", "님", "안녕하세요", "또 오셨군요"];
console.log(arr.join(" ")); // 이정환 님 안녕하세요 또 오셨군요
```

`join` 메서드 내부에 들어가는 파라미터는 구분자로, 이 구분자를 이용하여 요소들을 합칠때 사이사이에 무엇을 넣을 것인지 결정할 수 있습니다

```javascript
const arr = ["이정환", "님", "안녕하세요", "또 오셨군요"];
console.log(arr.join(", ")); // 이정환, 님, 안녕하세요, 또 오셨군요
```
