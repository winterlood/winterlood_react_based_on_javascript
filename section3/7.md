# 프로미스

안녕하세요 winterlood입니다.

이번 시간에는 가장 중요하고, 조금 어려울 수 있는 이야기를 다룰 겁니다.

바로 자바스크립트의 `비동기 처리`와, 그런 `비동기 처리`를 할 수 있도록 도와주는 `Promise`에 대한 내용입니다.

많이 어렵고 혼란스러울 수 있지만, 최대한 쉽게 풀어서 설명하도록 노력하겠습니다.

## 01. 동기?

이번시간에서 우리가 첫번째로 알아볼 것은 `비동기 처리`라는 개념입니다.

`비 동기 처리`의 반대말은 `동기적 처리`입니다. 그러니까 `비 동기적 처리`는 동기적이지 않게 처리한다는 뜻인데요,

도대체 `동기적 처리`는 뭐고 그 반대인 `비 동기적 처리`가 뭔지 벌써부터 혼란스러우므로,

`동기적 처리가`가 뭔지부터 차근차근 알아보도록 하겠습니다.

`동기적 처리`는 쉽게 말하면, 마치 맥도날드 키오스크 같은 느낌입니다. 앞의 사람이 주문하고 있으면 뒷사람은 동시에 주문할 수 없고 앞의 사람이 주문을 끝내야만 그때서야 뒷 사람이 주문할 수 있죠

이렇게 하나의 작업이 실행되는 (그러니까 한줄의 코드가 실행되는)동안은 다른 작업을 동시에 안하고 그냥 그 작업을 다 하고 나서 다음 작업을 한다는 뜻 입니다.

우리가 지금까지 작성해온 코드들은 방금 이야기한 맥도날드 키오스크 처럼 작성한 순서대로 동작했습니다.

```javascript
console.log("1");
console.log("2");
console.log("3");
console.log("4");
```

이 코드의 실행 결과는 어떤가요?

1,2,3,4가 순서대로 출력됩니다 그 이유는 너무 당연하게도, 우리가 그런 순서대로 배치를 했고 순서대로 처리되기 때문이죠

이렇게 그냥 작성한 순서대로, 위의 명령이 끝나면 바로 다음줄의 명령을 수행하는 방식을 `동기적 처리`이라고 부릅니다.

자바스크립트는 기본적으로 작성한 순서대로 작동하죠, 그래서 `동기적 언어`라고 부릅니다.

다시말해 `동기적 처리`이라는 뜻은 이전의 작업을 마치고나서, 다음의 작업을 수행한다는 의미입니다.

## 02. 비동기?

그렇다면 이런 `동기적 처리`의 반대인 `비동기적 처리`라는 것은 무엇일까요?

우리가 만약 인생을 `동기적`으로만 살면 어떻게 될까요? 앞의 작업이 끝나기 전에는 다음 작업을 하지 못하기 때문에

여러분은 아마 밥먹으면서 핸드폰으로 유튜브도 볼 수 없을겁니다.

왜냐면 동기적으로 이것을 처리하려면 밥을 다 먹고나서야 유튜브를 키던 말던 할 수 있거든요

그래서 우리는 `비 동기적 처리`를 할 수 있습니다. 밥을 먹으면서 동시에 유튜브도 볼 수 있으니까요

이렇게 `비 동기적 처리`라는것은 어떤 작업이 끝나길 기다리지 않고, 그냥 다음 작업도 동시에 하는 방식입니다.

자 그럼 대충 `동기적 처리`와 그 반대인 `비 동기적 처리`의 개념에 대해 조금은 이해했습니다.

이제는 이 두개의 개념을 자바스크립트 코드를 통해 실습해보도록 하겠습니다.

## 03. 자바스크립트의 비동기

자바스크립트는 기본적으로 동기적으로 작동하기 때문에, 우리가 지금까지 만든 모든 프로그램은 다 동기적으로 작동했습니다.

그러므로 바로 비동기적으로 작동하는 코드를 작성해보도록 하겠습니다.

이제부터는 실습을 통해 진행하겠습니다.

`CodeSandBox`로 넘어가 주세요

자바스크립트에서 가장 쉽게 `비 동기적 처리`를 연습해 볼 수 있는 좋은 내장 함수가 하나 있습니다.

`setTimeout`이라는 아무것도 하지 않고 그저 기다리기만 하는 특이한 함수인데요

한번 사용해보도록 하겠습니다.

```javascript
setTimeout(() => {
  console.log("다 기다렸어");
}, 3000);
```

뭔가 뜸 들이고 나서 "다 기다렸어"를 출력하면서, 우리가 전달한 콜백함수를 수행한 결과를 볼 수 있습니다.

이 `setTimeout`함수는 파라미터 2개를 입력받고 있습니다.

첫번째는 콜백함수, 두번째는 ms단위의 시간을 입력받는데요 참고로 ms 단위의 시간은 1초가 1000으로 환산된다고 생각하시면 됩니다.

그러니까 우리는 3초를 두번째 파라미터로 전달했고, 첫번째 파라미터 콜백함수에는 "다 기다렸어"라는 문자열을 콘솔에 출력하는 함수를 전달했다고 볼 수 있겠죠

이 `setTimeout`함수는 두번째로 받은 ms단위의 시간만큼 기다렸다가, 다 지나면 첫번째로 받은 콜백함수를 실행시키는 타이머를 생성하는 함수입니다.

이번에는 이 `setTimeout` 함수 호출이후에 바로 `console.log`를 출력 해 보도록 하겠습니다.

```javascript
setTimeout(() => {
  console.log("다 기다렸어");
}, 3000);

console.log("함수 호출 END");
```

이상하네요 `setTimeout`함수의 타이머를 기다리지 않고 그냥 바로 아래에 있는 `console`이 출력됩니다.

그리고 나서 3초 있다가 `setTimeout`함수의 콜백함수가 수행되네요

맞습니다. 이게 바로 `비 동기적 처리`입니다.

그럼 이러한 `비동기 적 처리`는 어떤 상황에서 이용하게 될까요?

가장 대표적으로 소개되는 `비동기 처리`의 사례는 API 호출 즉, 서버와의 통신입니다.

서버와의 통신의 대표적인 예로 넷플릭스 이야기를 해보겠습니다.

넷플릭스는 영화 드라마등의 영상 컨텐츠 스트리밍 서비스입니다.

이 `스트리밍`이라는 것은 영상을 다 다운로드 하지 않고, 실시간으로 조금조금씩 다운로드 하면서 지금 다운로드 된 곳 까지만 재생하는 방식입니다.

영상을 다운로드하는 작업이 끝나지 않아도 지금 다운로드 된 곳 까지만 재생하는 방식인 이것은 `비동기 적 처리`입니다.

넷플릭스 말고도, 유튜브 동영상도 그렇고, 스트리밍 말고도 로딩중에 다른 작업을 할 수 있는 웹 어플리케이션은 아주 많습니다.

이러한 모든 동시작업은 `비 동기적 처리`를 기반으로 합니다.

따라서 우리는 이 `비 동기적 처리`방식을 꼭 다룰 수 있어야 합니다.

## 02. Promise 없이 지금까지 배운대로 해보기

이제 비동기가 뭔지 알아보았습니다.

이제 우리는 이 비동기 처리를 자유 자재로 다루는 방법을 익히기만 하면 됩니다.

`CodeSandBox`에서 자바스크립트의 비동기 처리를 실제로 구현해보도록 하겠습니다.

간단한 비동기 처리를 만들어보기 위해

주어진 값이 100 이상인지 판별하여 3초 뒤에 결과를 반환하는 `비 동기` 함수를 만들어 보도록 하겠습니다.

```javascript
const isOverHunnit = (value) => {
  return setTimeout(() => {
    return value >= 100;
  }, 3000);
};

console.log(isOverHunnit(101));
```

3초 기다리지도 않고 무슨 이상한 숫자가 출력되는데요

이것은 `setTimeout`함수의 반환값은 콜백함수의 반환값이 아니라서 그렇습니다.

이 반환값은 `setTimeout` 타이머의 ID입니다.

결론적으로 우리가 하고싶은건, 3초 뒤에 전달한 값이 100이상인지 아닌지를 콘솔에 출력하고 싶은 것 이기 때문에

이럴때는 `isOverHunnit`함수에 결과를 출력하도록 하는 콜백함수를 전달하고, 그 함수를 `setTimeout`의 콜백함수에서 호출하면 됩니다.

```javascript
const isOverHunnit = (value, cb) => {
  setTimeout(() => {
    cb(value >= 100);
  }, 3000);
};

isOverHunnit(101, (res) => {
  console.log(res);
}); //
```

`isOverHunnit`에 결과값을 받아 그대로 출력하는 콜백함수를 `cb`라는 이름으로 전달합니다.

`cb` 콜백함수를 `setTimeout`의 콜백함수에서 호출하도록 하여, 3초뒤에 이 콜백함수 `cb`를 실행하도록 만듭니다. 이 때 인자는 100이 넘는지 아닌지를 판별하는 결과를 넣어주면 됩니다.

## 03. 콜백지옥

자 그런데 이렇게 하면 벌써 콜백함수를 두개나 사용해야 합니다.

만약 100이 넘지 않으면 또 50을 넘는지 판독하는 함수를 추가하고, 50이 넘지 않으면 25를 넘는지 판독하는 함수를 추가하면 콜백함수를 몇번이나 써야 할까요?

이런 `비 동기 처리`프로그래밍을 하면서 발생하는 문제를 `콜백 지옥`이라고 부릅니다.

이럴때는 `비 동기 처리`전용 객체인 `Promise`를 사용하면 됩니다.

## 03. Promise

### 3-1. Promise란?

`Promise`는 자바스크립트의 내장 객체인데요, 이 객체는 비동기처리를 도와 콜백지옥을 피할 수 있도록 도와줍니다.

자 그러면 직접 `Promise`객체를 만들어 보겠습니다.

```javascript
const func = new Promise(); // <- executer는 함수입니다.
```

`Promise` 객체는 이렇게 `new` 키워드와 생성자를 이용하여 생성하여야 합니다.

이 때 생성자에는 `executer`라는 콜백함수 하나가 반드시 들어가야 합니다.

```javascript
const executer = (resolve, reject) => {
  // your logic is here
};
const func = new Promise(executer);
```

이 `Promise`객체를 생성시에 전달되는 `executer` 함수는 비동기 처리의 주체가 되는 함수입니다.

그럼 이 `executer`함수를 디테일하게 살펴보도록 하겠습니다.

우선 이 `executer`함수의 명령블록 내에는 비동기 처리 코드를 작성하면 됩니다.

```javascript
const executer = (resolve, reject) => {
  setTimeout(() => {
    console.log("HA");
  }, 3000);
};
const func = new Promise(executer);
```

이 `Promise`생성자에 전달한 `executer`함수는 생성과 즉시 자동으로 실행됩니다.

따라서 3초 이후에 `HA`라는 결과값이 콘솔에 출력되는 것을 확인할 수 있습니다.

이번에는 아까 예제에서 해본 주어진 값이 100이 넘는지 아닌지 3초뒤에 판단하는 비동기 작업을 `executer`를 이용해서 해보도록 하겠습니다.

```javascript
const executer = (resolve, reject) => {
  const number = 99;
  setTimeout(() => {
    if (number >= 100) {
      console.log("over 100");
    } else {
      console.log("under 100");
    }
  }, 3000);
};
const func = new Promise(executer);
```

아까와 똑같이 이렇게 `executer`함수 내에 원하는 로직을 작성해주면 됩니다.

### 3-2. Promise resolve

그러면 이번에는 이 100인지 아닌지 판단한 결과를 값으로 직접 반환받아 보도록 하겠습니다.

```javascript
const executer = (resolve, reject) => {
  const number = 101;
  setTimeout(() => {
    if (number >= 100) {
      resolve("over 100");
    } else {
      resolve("under 100"); //
    }
  }, 3000); //
};
const func = new Promise(executer);

func.then((res) => {
  console.log(res);
});
```

`executer`함수에서 비동기 처리된 결과 값을 반환할때는, 파라미터로 받은 `resolve` 콜백함수에 결과값을 전달하면 됩니다.

`resolve`콜백함수에 전달된 값은 `Promise`객체의 `then`메서드를 사용하여 이용할 수 있습니다.

이 `then`메서드에는 `executer` 함수에서 전달한 값이 파라미터로 전달됩니다.

그러므로 `executer`에서 `resolve`에 전달한 문자열 "over 100"이 `then`메서드의 파라미터로 전달되었고, 이것을 콘솔에 출력하면서 비동기 처리를 성공적으로 할 수 있게 되었습니다.

`executer`의 파라미터중 `resolve`는 이렇게 비동기 작업이 성공하였을 때의 결과를 전달하는데에 사용됩니다.

### 3-3. Promise reject

비 동기 처리는 성공할 수도 실패할 수도 있습니다.

물론 우리가 만든 이 100인지 아닌지를 판단하는데에는 실패할리 없겠지만, API 호출과 같은 서버상태에 따라 결과가 달라지는 경우에는 충분히 실패할 수 있습니다.

해당 서버가 터졌을수도, 현재 마비상태일수도 또는 버그가 발생했을 수도 있으니까요

이번에는 100을 넘지 않으면 비동기 처리가 실패했다고 가정해보고, 실패시에 `Promise`객체를 통해 에러 핸들링 하는 법을 배워보도록 하겠습니다.

```javascript
const executer = (resolve, reject) => {
  const number = 50;
  setTimeout(() => {
    if (number >= 100) {
      resolve("over 100");
    } else {
      reject("under 100"); //
    }
  }, 3000); //
};
const func = new Promise(executer);

func
  .then((res) => {
    console.log("success : ", res);
  })
  .catch((err) => {
    console.log("error : ", err);
  });
```

`executer`의 두번째 파라미터 `reject`는 비동기 처리가 실패했을때의 값을 전달하기 위한 콜백함수 입니다.

이 `reject` 콜백함수를 호출할 때 실패 결과값을 전달하게되면, `Promise`객체의 `catch`메서드를 이용하여 실패의 결과값을 받아 볼 수 있습니다.

그러면 여기서 재미있는 실험을 한번 해보겠습니다.

만약 `executer`함수에서 `resolve`나 `reject`를 두번 호출하면 어떻게 될까요?

```javascript
const executer = (resolve, reject) => {
  const number = 50;
  setTimeout(() => {
    if (number >= 100) {
      resolve("over 100");
    } else {
      reject("under 100"); //
      reject("두번째 reject"); //
    }
  }, 3000); //
};
const func = new Promise(executer);

func
  .then((res) => {
    console.log("success : ", res);
  })
  .catch((err) => {
    console.log("error : ", err);
  });
```

두번째로 작성한 `reject`가 전달한 값은 `catch`메서드에 전달되지 않습니다.

이것은 `Promise`객체로 수행하는 모든 비동기 처리는 3가지 상태를 갖기 때문인데요

PPT를 통해 자세히 알아보도록 하겠습니다.

### 3-4. Promise의 상태 이해하기

자바스크립트의 비동기 처리를 위한 `Promise`객체는 아래 세가지 중 하나의 상태를 가집니다

1. 대기(pending): 작업이 아직 종료되지 않았거나, 무언가 문제가 발생했을때 (오류)
2. 이행(fulfilled): 작업이 성공함
3. 거부(rejected): 작업이 실패함.

![](https://mdn.mozillademos.org/files/8633/promises.png)

> 출처 MDN : promise 설명 이미지

위 `Promise`의 상태와 동작방식을 나타내는 사진 자료를 보면, 이미 작업이 수행되어 `then`이나 `catch`가 수행된 `Promise`객체는 실행을 멈추는 것을 알 수 있습니다.

즉, `Promise`는 `resolve`나, `reject`를 한번 이상 호출한 뒤에는 비동기 처리는 사실상 종료상태인 이행이나, 거부 상태가 되기 때문에 아무런 추가적인 동작을 하지 않습니다.

### 3-5. 진짜 비동기 작업을 Promise로 처리하기

자 그러면 이번에는 이 `Promise`객체를 조금 더 사용해보도록 하겠습니다.

우리가 아까 만든 3초 뒤에 100이 넘는지 아닌지 판단하는 프로그램은, 판단 대상 숫자가 고정되어 있었는데요, 이것을 `Promise`를 반환하는 함수로 제작하여 조금 더 유용하게 사용해보도록 만들어보겠습니다.

```javascript
const isOverHunnit = (number) => {
  return new Promise((resolve, reject) => {
    const number = 50;
    setTimeout(() => {
      if (number >= 100) {
        resolve("over 100");
      } else {
        reject("under 100"); //
        reject("두번째 reject"); //
      }
    }, 3000); //
  });
};

const func = isOverHunnit(50);

func
  .then((res) => {
    console.log("success : ", res);
  })
  .catch((err) => {
    console.log("error : ", err);
  });
```

이렇게 함수에서 `Promise`객체를 반환하도록 하여, 더 유연한 비동기 처리를 할 수 있습니다.

이렇게 동기와 비동기의 개념과 자바스크립트의 비동기 처리를위한 `Promise`객체와 사용법까지 다루어 보았습니다.

이번시간은 여기서 마무리하고, 저는 다음시간에 다시 인사드리도록 하겠습니다.
